// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.19.1
// source: kira/recovery/tx.proto

package types

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Msg_RegisterRecoverySecret_FullMethodName             = "/kira.recovery.Msg/RegisterRecoverySecret"
	Msg_RotateRecoveryAddress_FullMethodName              = "/kira.recovery.Msg/RotateRecoveryAddress"
	Msg_IssueRecoveryTokens_FullMethodName                = "/kira.recovery.Msg/IssueRecoveryTokens"
	Msg_BurnRecoveryTokens_FullMethodName                 = "/kira.recovery.Msg/BurnRecoveryTokens"
	Msg_ClaimRRHolderRewards_FullMethodName               = "/kira.recovery.Msg/ClaimRRHolderRewards"
	Msg_RegisterRRTokenHolder_FullMethodName              = "/kira.recovery.Msg/RegisterRRTokenHolder"
	Msg_RotateValidatorByHalfRRTokenHolder_FullMethodName = "/kira.recovery.Msg/RotateValidatorByHalfRRTokenHolder"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MsgClient interface {
	// allow ANY user to register or modify existing recovery secret & verify if the nonce is correct
	RegisterRecoverySecret(ctx context.Context, in *MsgRegisterRecoverySecret, opts ...grpc.CallOption) (*MsgRegisterRecoverySecretResponse, error)
	// allow ANY KIRA address that knows the recovery secret to rotate the address
	RotateRecoveryAddress(ctx context.Context, in *MsgRotateRecoveryAddress, opts ...grpc.CallOption) (*MsgRotateRecoveryAddressResponse, error)
	// mint `rr_<moniker>` tokens and deposit them to the validator account.
	// This function will require putting up a bond in the amount of `validator_recovery_bond` otherwise should fail
	IssueRecoveryTokens(ctx context.Context, in *MsgIssueRecoveryTokens, opts ...grpc.CallOption) (*MsgIssueRecoveryTokensResponse, error)
	// burn tokens and redeem KEX
	BurnRecoveryTokens(ctx context.Context, in *MsgBurnRecoveryTokens, opts ...grpc.CallOption) (*MsgBurnRecoveryTokensResponse, error)
	// claim rewards
	ClaimRRHolderRewards(ctx context.Context, in *MsgClaimRRHolderRewards, opts ...grpc.CallOption) (*MsgClaimRRHolderRewardsResponse, error)
	// register RR token holder
	RegisterRRTokenHolder(ctx context.Context, in *MsgRegisterRRTokenHolder, opts ...grpc.CallOption) (*MsgRegisterRRTokenHolderResponse, error)
	// allow ANY KIRA address has a sufficient number of RR tokens to rotate the address
	RotateValidatorByHalfRRTokenHolder(ctx context.Context, in *MsgRotateValidatorByHalfRRTokenHolder, opts ...grpc.CallOption) (*MsgRotateValidatorByHalfRRTokenHolderResponse, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) RegisterRecoverySecret(ctx context.Context, in *MsgRegisterRecoverySecret, opts ...grpc.CallOption) (*MsgRegisterRecoverySecretResponse, error) {
	out := new(MsgRegisterRecoverySecretResponse)
	err := c.cc.Invoke(ctx, Msg_RegisterRecoverySecret_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RotateRecoveryAddress(ctx context.Context, in *MsgRotateRecoveryAddress, opts ...grpc.CallOption) (*MsgRotateRecoveryAddressResponse, error) {
	out := new(MsgRotateRecoveryAddressResponse)
	err := c.cc.Invoke(ctx, Msg_RotateRecoveryAddress_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IssueRecoveryTokens(ctx context.Context, in *MsgIssueRecoveryTokens, opts ...grpc.CallOption) (*MsgIssueRecoveryTokensResponse, error) {
	out := new(MsgIssueRecoveryTokensResponse)
	err := c.cc.Invoke(ctx, Msg_IssueRecoveryTokens_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnRecoveryTokens(ctx context.Context, in *MsgBurnRecoveryTokens, opts ...grpc.CallOption) (*MsgBurnRecoveryTokensResponse, error) {
	out := new(MsgBurnRecoveryTokensResponse)
	err := c.cc.Invoke(ctx, Msg_BurnRecoveryTokens_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimRRHolderRewards(ctx context.Context, in *MsgClaimRRHolderRewards, opts ...grpc.CallOption) (*MsgClaimRRHolderRewardsResponse, error) {
	out := new(MsgClaimRRHolderRewardsResponse)
	err := c.cc.Invoke(ctx, Msg_ClaimRRHolderRewards_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterRRTokenHolder(ctx context.Context, in *MsgRegisterRRTokenHolder, opts ...grpc.CallOption) (*MsgRegisterRRTokenHolderResponse, error) {
	out := new(MsgRegisterRRTokenHolderResponse)
	err := c.cc.Invoke(ctx, Msg_RegisterRRTokenHolder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RotateValidatorByHalfRRTokenHolder(ctx context.Context, in *MsgRotateValidatorByHalfRRTokenHolder, opts ...grpc.CallOption) (*MsgRotateValidatorByHalfRRTokenHolderResponse, error) {
	out := new(MsgRotateValidatorByHalfRRTokenHolderResponse)
	err := c.cc.Invoke(ctx, Msg_RotateValidatorByHalfRRTokenHolder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility
type MsgServer interface {
	// allow ANY user to register or modify existing recovery secret & verify if the nonce is correct
	RegisterRecoverySecret(context.Context, *MsgRegisterRecoverySecret) (*MsgRegisterRecoverySecretResponse, error)
	// allow ANY KIRA address that knows the recovery secret to rotate the address
	RotateRecoveryAddress(context.Context, *MsgRotateRecoveryAddress) (*MsgRotateRecoveryAddressResponse, error)
	// mint `rr_<moniker>` tokens and deposit them to the validator account.
	// This function will require putting up a bond in the amount of `validator_recovery_bond` otherwise should fail
	IssueRecoveryTokens(context.Context, *MsgIssueRecoveryTokens) (*MsgIssueRecoveryTokensResponse, error)
	// burn tokens and redeem KEX
	BurnRecoveryTokens(context.Context, *MsgBurnRecoveryTokens) (*MsgBurnRecoveryTokensResponse, error)
	// claim rewards
	ClaimRRHolderRewards(context.Context, *MsgClaimRRHolderRewards) (*MsgClaimRRHolderRewardsResponse, error)
	// register RR token holder
	RegisterRRTokenHolder(context.Context, *MsgRegisterRRTokenHolder) (*MsgRegisterRRTokenHolderResponse, error)
	// allow ANY KIRA address has a sufficient number of RR tokens to rotate the address
	RotateValidatorByHalfRRTokenHolder(context.Context, *MsgRotateValidatorByHalfRRTokenHolder) (*MsgRotateValidatorByHalfRRTokenHolderResponse, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (UnimplementedMsgServer) RegisterRecoverySecret(context.Context, *MsgRegisterRecoverySecret) (*MsgRegisterRecoverySecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterRecoverySecret not implemented")
}
func (UnimplementedMsgServer) RotateRecoveryAddress(context.Context, *MsgRotateRecoveryAddress) (*MsgRotateRecoveryAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RotateRecoveryAddress not implemented")
}
func (UnimplementedMsgServer) IssueRecoveryTokens(context.Context, *MsgIssueRecoveryTokens) (*MsgIssueRecoveryTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IssueRecoveryTokens not implemented")
}
func (UnimplementedMsgServer) BurnRecoveryTokens(context.Context, *MsgBurnRecoveryTokens) (*MsgBurnRecoveryTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnRecoveryTokens not implemented")
}
func (UnimplementedMsgServer) ClaimRRHolderRewards(context.Context, *MsgClaimRRHolderRewards) (*MsgClaimRRHolderRewardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimRRHolderRewards not implemented")
}
func (UnimplementedMsgServer) RegisterRRTokenHolder(context.Context, *MsgRegisterRRTokenHolder) (*MsgRegisterRRTokenHolderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterRRTokenHolder not implemented")
}
func (UnimplementedMsgServer) RotateValidatorByHalfRRTokenHolder(context.Context, *MsgRotateValidatorByHalfRRTokenHolder) (*MsgRotateValidatorByHalfRRTokenHolderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RotateValidatorByHalfRRTokenHolder not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_RegisterRecoverySecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterRecoverySecret)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterRecoverySecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RegisterRecoverySecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterRecoverySecret(ctx, req.(*MsgRegisterRecoverySecret))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RotateRecoveryAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRotateRecoveryAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RotateRecoveryAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RotateRecoveryAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RotateRecoveryAddress(ctx, req.(*MsgRotateRecoveryAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IssueRecoveryTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIssueRecoveryTokens)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IssueRecoveryTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_IssueRecoveryTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IssueRecoveryTokens(ctx, req.(*MsgIssueRecoveryTokens))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnRecoveryTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnRecoveryTokens)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnRecoveryTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BurnRecoveryTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnRecoveryTokens(ctx, req.(*MsgBurnRecoveryTokens))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimRRHolderRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimRRHolderRewards)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimRRHolderRewards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ClaimRRHolderRewards_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimRRHolderRewards(ctx, req.(*MsgClaimRRHolderRewards))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterRRTokenHolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterRRTokenHolder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterRRTokenHolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RegisterRRTokenHolder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterRRTokenHolder(ctx, req.(*MsgRegisterRRTokenHolder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RotateValidatorByHalfRRTokenHolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRotateValidatorByHalfRRTokenHolder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RotateValidatorByHalfRRTokenHolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RotateValidatorByHalfRRTokenHolder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RotateValidatorByHalfRRTokenHolder(ctx, req.(*MsgRotateValidatorByHalfRRTokenHolder))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kira.recovery.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterRecoverySecret",
			Handler:    _Msg_RegisterRecoverySecret_Handler,
		},
		{
			MethodName: "RotateRecoveryAddress",
			Handler:    _Msg_RotateRecoveryAddress_Handler,
		},
		{
			MethodName: "IssueRecoveryTokens",
			Handler:    _Msg_IssueRecoveryTokens_Handler,
		},
		{
			MethodName: "BurnRecoveryTokens",
			Handler:    _Msg_BurnRecoveryTokens_Handler,
		},
		{
			MethodName: "ClaimRRHolderRewards",
			Handler:    _Msg_ClaimRRHolderRewards_Handler,
		},
		{
			MethodName: "RegisterRRTokenHolder",
			Handler:    _Msg_RegisterRRTokenHolder_Handler,
		},
		{
			MethodName: "RotateValidatorByHalfRRTokenHolder",
			Handler:    _Msg_RotateValidatorByHalfRRTokenHolder_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kira/recovery/tx.proto",
}
